<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // 给你一个整数数组 nums 和一个整数 target 。
    // 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
    // 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
    // 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
    var findTargetSumWays = function(nums, target) {
        // 将数组分成两份，l和r，l是正数，r是负数。那么l + r = target; l - r = sum; l = (sum + target) / 2;
        // 问题转化为即求 将容量为l的背包装满有多少种方法
        // 举例[1,1,1,1,1], target = 3, 即l = 4 = j
        //   0 1 2 3 4 --- j
        // 1 1 1 0 0 0
        // 1 1 2 1 0 0
        // 1 1 3 3 1 0
        // 1 1 4 6 4 1
        // 1 5 10 10 5
        // i
        // 即 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]
        // 转为一维数组 dp[j] = dp[j] + dp[j - nums[i]]
        var sum = nums.reduce((a, b) => a + b);
        var isOdd = (sum + target) % 2 === 0;
        if (!isOdd) return 0;
        if (Math.abs(target) > sum) return 0;

        var l =(sum + target) / 2;
        var dp = new Array(l + 1).fill(0);
        dp[0] = 1;
        console.log(dp);
        for(var i = 0; i < nums.length; i++) {
            for(var j = l; j >= nums[i]; j--) {
                dp[j] = dp[j] + dp[j - nums[i]];
            }
        }
        console.log(dp);
        console.log(dp[l]);
        return dp[l];
    }
    findTargetSumWays([1,1,1,1,1], 3);
    findTargetSumWays([0,0,0,0,0,0,0,0,1], 1);
</script>
</html>